<?php

namespace Gist\InventoryBundle\Controller;

use Gist\TemplateBundle\Model\CrudController;
use Gist\InventoryBundle\Entity\Product;
use Gist\InventoryBundle\Entity\DamagedItems;
use Gist\InventoryBundle\Entity\OpenTesterEntry;
use Gist\CoreBundle\Template\Controller\TrackCreate;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Gist\InventoryBundle\Entity\Transaction;
use Gist\InventoryBundle\Entity\Entry;
use Gist\InventoryBundle\Entity\Stock;
use DateTime;

class OpenTesterController extends CrudController
{

    use TrackCreate;

    /**
     * DamagedItemsController constructor.
     */
    public function __construct()
    {
        $this->route_prefix = 'gist_inv_damaged_items';
        $this->list_type = 'dynamic';
        $this->repo = "GistInventoryBundle:OpenTesterEntry";
    }

    /**
     * @param $obj
     * @return string
     */
    protected function getObjectLabel($obj)
    {
        if ($obj == null)
        {
            return '';
        }
        return $obj->getID();
    }

    /**
     * @return DamagedItemsEntry
     */
    protected function newBaseClass()
    {
        return new DamagedItemsEntry();
    }

    /**
     *
     * For POS Open Tester Grid
     * (copy damaged items grid implementation)
     *
     * @param $pos_loc_id
     * @return JsonResponse
     */
    public function getOpenTesterDataAction($pos_loc_id)
    {
        header("Access-Control-Allow-Origin: *");
        $em = $this->getDoctrine()->getManager();
        $pos_location = $em->getRepository('GistLocationBundle:POSLocations')->findOneBy(array('id'=>$pos_loc_id));
        $stock = $em->getRepository('GistInventoryBundle:OpenTesterEntry')->findBy(array('destination_inv_account'=>$pos_location->getInventoryAccount()->getTesterContainer()->getID()));
        $list_opts = [];
        foreach ($stock as $p) {
            $closing_user = '';
            if ($p->getClosingUser() != '') {
                $closing_user = $p->getClosingUser()->getDisplayName();
            }
            $list_opts[] = array(
                'id' => $p->getID(),
                'item_code' =>$p->getProduct()->getItemCode(),
                'barcode' => $p->getProduct()->getBarcode(),
                'item_name' => $p->getProduct()->getName(),
                'statusFMTD' => $p->getStatusFMTD(),
                'date_create' => $p->getDateCreateFormatted(),
                'user_create' => $p->getOpeningUser()->getDisplayName(),
                'date_consumed' => $p->getDateConsumedFormatted(),
                'user_consumed' => $closing_user,
                'flag_pickedup' => $p->isPickedUp(),
            );

        }

        $list_opts = array_map("unserialize", array_unique(array_map("serialize", $list_opts)));
        return new JsonResponse($list_opts);
    }

    /**
     *
     * For POS Open Tester Grid Summary
     * (copy damaged items summary implementation)
     *
     * @param $pos_loc_id
     */
    public function getOpenTesterDataSummaryAction($pos_loc_id)
    {
        $em = $this->getDoctrine()->getManager();
    }

    /**
     * @return Response
     * @internal param $pos_loc_id
     */
    public function getItemsForTesterOptionsAction($category = null)
    {
        //exclude items that are in pos' tester container
        //$mainPOS = new MainPOSController();
        //return $mainPOS->gridSearchProductAction(null, null);
        $resp = new Response('slkdf');
        $resp->headers->set('Content-Type', 'application/json');

        return $resp;
    }

    /**
     * @param $pos_loc_id
     * @param $entries
     * @return JsonResponse
     */
    public function saveOpenTesterDataAction($pos_loc_id, $uid, $entries)
    {
        header("Access-Control-Allow-Origin: *");
        $em = $this->getDoctrine()->getManager();
        $inv = $this->get('gist_inventory');
        $config = $this->get('gist_configuration');
        $user = $em->getRepository('GistUserBundle:User')->findOneBy(array('id'=>$uid));
        parse_str(html_entity_decode($entries), $entriesParsed);


        foreach ($entriesParsed as $e) {
            $prod_item_code = $e['item_code'];
            $qty = 1;
            $prod = $em->getRepository('GistInventoryBundle:Product')->findOneBy(array('item_code'=>$prod_item_code));
            if ($prod == null)
                throw new ValidationException('Could not find product.');

            //from src
            $entry = new OpenTesterEntry();
            $entry->setProduct($prod)
                ->setQuantity($qty);


            $wh_src = $em->getRepository('GistLocationBundle:POSLocations')->find($pos_loc_id);
            $wh_destination = $wh_src->getInventoryAccount()->getTesterContainer();


            $entry->setSource($wh_src->getInventoryAccount());
            $entry->setDestination($wh_destination);

            $entry->setStatus('opened');
            $entry->setOpeningUser($user);
            $entry->setRemarks($e['remarks']);

            $em->persist($entry);
            $em->flush();

            //CREATE STOCK ENTRIES
            $entries = array();
            $remarks = $e['remarks'];
            $new_qty = 1;
            $old_qty = 0;

            if ($remarks == '') {
                $remarks = '[POS] Transfer to damaged container';
            }

            // setup transaction
            $trans = new Transaction();
            $trans->setUserCreate($this->getUser())
                ->setDescription($remarks);

            // add entries
            // entry for destination
            $wh_entry = new Entry();
            $wh_entry->setInventoryAccount($wh_destination)
                ->setProduct($prod);

            // entry for source
            $adj_entry = new Entry();
            $adj_entry->setInventoryAccount($wh_src->getInventoryAccount())
                ->setProduct($prod);

            // check if debit or credit
            if ($new_qty > $old_qty)
            {
                $qty = $new_qty - $old_qty;
                $wh_entry->setDebit($qty);
                $adj_entry->setCredit($qty);
            }
            else
            {
                $qty = $old_qty - $new_qty;
                $wh_entry->setCredit($qty);
                $adj_entry->setDebit($qty);
            }
            $entries[] = $wh_entry;
            $entries[] = $adj_entry;

            foreach ($entries as $ent)
                $trans->addEntry($ent);

            $inv->persistTransaction($trans);
            $em->flush();
        }

        $list_opts[] = array(
            'status'=>'success'
        );

        return new JsonResponse($list_opts);
    }

    public function updateOpenTesterPickupAction($id, $uid)
    {
        $em = $this->getDoctrine()->getManager();
        $inv = $this->get('gist_inventory');
        $config = $this->get('gist_configuration');
        $entry = $em->getRepository('GistInventoryBundle:OpenTesterEntry')->findOneBy(array('id'=>$id));
        $user = $em->getRepository('GistUserBundle:User')->findOneBy(array('id'=>$uid));

        $entry->setPickedUp(true);

        $em->persist($entry);
        $em->flush();

        $list_opts[] = array(
            'status'=>'success'
        );

        return new JsonResponse($list_opts);
    }

    /**
     * @param $id
     * @param $uid
     * @return JsonResponse
     * @internal param $pos_loc_id
     * @internal param $ot_id -> this is the open tester entry id
     */
    public function updateOpenTesterStatusAction($id, $uid)
    {
        $em = $this->getDoctrine()->getManager();
        $inv = $this->get('gist_inventory');
        $config = $this->get('gist_configuration');
        $entry = $em->getRepository('GistInventoryBundle:OpenTesterEntry')->findOneBy(array('id'=>$id));
        $user = $em->getRepository('GistUserBundle:User')->findOneBy(array('id'=>$uid));


        $prod = $entry->getProduct();

        //from src

        $wh_src = $entry->getSource()->getTesterContainer();
        $wh_destination = $inv->findWarehouse($config->get('gist_adjustment_warehouse'));
        //$wh_destination = $wh_destination->getInventoryAccount();


        $entry->setStatus('consumed');
        $entry->setClosingUser($user);
        $entry->setDateConsumed(new DateTime());
        //$entry->setRemarks($e['remarks']);

        $em->persist($entry);
        $em->flush();

        //CREATE STOCK ENTRIES
        $entries = array();
        //$remarks = $e['remarks'];
        $new_qty = 1;
        $old_qty = 0;


        $remarks = '[POS] Tester Item Consumed';


        // setup transaction
        $trans = new Transaction();
        $trans->setUserCreate($this->getUser())
            ->setDescription($remarks);

        // add entries
        // entry for destination
        $wh_entry = new Entry();
        $wh_entry->setInventoryAccount($wh_destination->getInventoryAccount())
            ->setProduct($prod);

        // entry for source
        $adj_entry = new Entry();
        $adj_entry->setInventoryAccount($wh_src)
            ->setProduct($prod);

        // check if debit or credit
        if ($new_qty > $old_qty)
        {
            $qty = $new_qty - $old_qty;
            $wh_entry->setDebit($qty);
            $adj_entry->setCredit($qty);
        }
        else
        {
            $qty = $old_qty - $new_qty;
            $wh_entry->setCredit($qty);
            $adj_entry->setDebit($qty);
        }
        $entries[] = $wh_entry;
        $entries[] = $adj_entry;

        foreach ($entries as $ent)
            $trans->addEntry($ent);

        $inv->persistTransaction($trans);
        $em->flush();

        $list_opts[] = array(
            'status'=>'success'
        );

        return new JsonResponse($list_opts);

    }

    public function getPOSTesterStockAction($pos_loc_id)
    {
        header("Access-Control-Allow-Origin: *");
        $em = $this->getDoctrine()->getManager();
        $pos_location = $em->getRepository('GistLocationBundle:POSLocations')->findOneBy(array('id'=>$pos_loc_id));
        $stock = $em->getRepository('GistInventoryBundle:Stock')->findBy(array('inv_account'=>$pos_location->getInventoryAccount()->getTesterContainer()->getID()));

        $list_opts = [];
        foreach ($stock as $p) {
            if ($p->getQuantity() > 0) {
                $list_opts[] = array(
                    'item_code' =>$p->getProduct()->getItemCode(),
                    'barcode' => $p->getProduct()->getBarcode(),
                    'item_name' => $p->getProduct()->getName(),
                    'quantity' => $p->getQuantity(),
                );
            }
        }

        $list_opts = array_map("unserialize", array_unique(array_map("serialize", $list_opts)));
        return new JsonResponse($list_opts);
    }

    public function gridSearchProductAction($pos_loc_id, $category = null)
    {
        $this->hookPreAction();
        $this->repo = 'GistInventoryBundle:Product';
        $gloader = $this->setupGridLoaderAjax();
        $gloader->setRepository('GistInventoryBundle:Product');
        $gloader->setQBFilterGroup($this->filterProductSearch($pos_loc_id, $category));
        $gres = $gloader->load();
        $resp = new Response($gres->getJSON());
        $resp->headers->set('Content-Type', 'application/json');

        return $resp;
    }

    protected function filterProductSearch($pos_loc_id, $category = null)
    {
        $grid = $this->get('gist_grid');
        $fg = $grid->newFilterGroup();
        $em = $this->getDoctrine()->getManager();
        $pos_location = $em->getRepository('GistLocationBundle:POSLocations')->findOneBy(array('id'=>$pos_loc_id));
        $stock = $em->getRepository('GistInventoryBundle:Stock')->findBy(array('inv_account'=>$pos_location->getInventoryAccount()->getTesterContainer()->getID()));
        $prod_ids = [];
        foreach ($stock as $s) {
            if (round($s->getQuantity(),0) >= $s->getProduct()->getMaxTester()) {
                array_push($prod_ids, $s->getProduct()->getID());
            }

        }

        if($category != null and $category != 'null') {
            $qry[] = "(o.category = '".$category."')";
        }

        if (count($prod_ids) <= 0) {
            $qry[] = "(o.id NOT IN (0))";
        } else {
            $qry[] = "(o.id NOT IN (".implode(",", $prod_ids)."))";
        }


        //

        if (!empty($qry))
        {
            $filter = implode(' AND ', $qry);
        }

        return $fg->where($filter);
    }

    protected function setupGridLoaderAjax()
    {
        $data = $this->getRequest()->query->all();
        $grid = $this->get('gist_grid');

        $gloader = $grid->newLoader();
        $gloader->processParams($data)
            ->setRepository($this->repo);

        $gcols = $this->getGridColumnsAjax();

        if ($this->list_type == 'dynamic')
            $gcols[] = $grid->newColumn('', 'getID', null, 'o', array($this, 'callbackGridAjax'), false, false);

        foreach ($gcols as $gc)
            $gloader->addColumn($gc);

        return $gloader;
    }

    protected function getGridColumnsAjax()
    {
        $grid = $this->get('gist_grid');
        return array(
            $grid->newColumn('Item Code', 'getItemCode', 'item_code','o', array($this,'formatItemCode')),
            $grid->newColumn('Barcode','getBarcode','barcode'),
            $grid->newColumn('Name', 'getName', 'name','o', array($this,'formatItemName')),
        );
    }

    public function callbackGridAjax($id)
    {
        $params = array(
            'id' => $id,
            'route_edit' => $this->getRouteGen()->getEdit(),
            'route_delete' => $this->getRouteGen()->getDelete(),
            'prefix' => $this->route_prefix,
        );

        $this->padGridParams($params, $id);

        $engine = $this->get('templating');
        return $engine->render(
            'GistInventoryBundle:DamagedItems:action_search.html.twig',
            $params
        );
    }

    public function formatItemCode($val)
    {
        return '<input type="hidden" class="itemCode" value="'.$val.'">'.$val;
    }

    public function formatItemName($val)
    {
        return '<input type="hidden" class="itemName" value="'.$val.'">'.$val;
    }
}
